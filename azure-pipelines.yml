# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

variables:
  outputFolder: './_output'
  artifactsFolder: './_artifacts'
  testsFolder: './_tests'
  majorVersion: '0.1.0'
  minorVersion: $[counter('minorVersion', 1)]
  readarrVersion: '$(majorVersion).$(minorVersion)'
  buildName: '$(Build.SourceBranchName).$(readarrVersion)'
  sentryOrg: 'servarr'
  sentryUrl: 'https://sentry.servarr.com'
  dotnetVersion: '3.1.401'
  yarnCacheFolder: $(Pipeline.Workspace)/.yarn
  nugetCacheFolder: $(Pipeline.Workspace)/.nuget/packages

trigger:
  branches:
    include:
    - develop
    - master

pr:
- develop

stages:
  - stage: Setup
    displayName: Setup
    jobs:
    - job:
      displayName: Build Variables
      pool:
        vmImage: 'ubuntu-18.04'
      steps:
      # Set the build name properly.  The 'name' property won't recursively expand so hack here:
      - bash: echo "##vso[build.updatebuildnumber]$READARRVERSION"
        displayName: Set Build Name
      - bash: |
          if [[ $BUILD_REASON == "PullRequest" ]]; then
          git diff origin/develop...HEAD  --name-only | grep -E "^(src/|azure-pipelines.yml)"
          echo $? > not_backend_update
          else
          echo 0 > not_backend_update
          fi
          cat not_backend_update
        displayName: Check for Backend File Changes
      - publish: not_backend_update
        artifact: not_backend_update
        displayName: Publish update type

  - stage: Build_Backend
    displayName: Build Backend
    dependsOn: Setup
    jobs:

    - job: Backend_Windows
      pool:
        vmImage: 'windows-2019'
      variables:
        # Disable stylecop here - linting errors get caught by the analyze task
        EnableAnalyzers: 'false'
      steps:
      - checkout: self
        fetchDepth: 1
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - task: Cache@2
        inputs:
          key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**,!**/_tests/**,!**/_output/**'
          restoreKeys: |
            nuget | "$(Agent.OS)"
            nuget
          path: $(nugetCacheFolder)
        displayName: Cache NuGet packages
      - bash: ./build.sh --backend -r win-x64 -f netcoreapp3.1
        displayName: Build Readarr Backend
        env:
          NUGET_PACKAGES: $(nugetCacheFolder)
        # Stuff for creating packages later without full checkout

      - template: publish-template.yml
        parameters:
          folder: $(outputFolder)
          type: backend
          rids:
          - framework: netcoreapp3.1
            rid: win-x64

      - template: publish-template.yml
        parameters:
          folder: '$(outputFolder)/Readarr.Update'
          type: update
          rids:
          - framework: netcoreapp3.1
            rid: win-x64

      - template: publish-template.yml
        parameters:
          folder: $(testsFolder)
          type: tests
          rids:
          - framework: netcoreapp3.1
            rid: win-x64

    - job: Backend_Linux
      pool:
        vmImage: 'ubuntu-18.04'
      variables:
        # Disable stylecop here - linting errors get caught by the analyze task
        EnableAnalyzers: 'false'
      steps:
      - checkout: self
        fetchDepth: 1
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - task: Cache@2
        inputs:
          key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**,!**/_tests/**,!**/_output/**'
          restoreKeys: |
            nuget | "$(Agent.OS)"
            nuget
          path: $(nugetCacheFolder)
        displayName: Cache NuGet packages
      - bash: ./build.sh --backend
        displayName: Build Readarr Backend
        env:
          NUGET_PACKAGES: $(nugetCacheFolder)
        # Stuff for creating packages later without full checkout
      - publish: build.sh
        artifact: build.sh
      - publish: macOS
        artifact: MacWrapper

      - template: publish-template.yml
        parameters:
          folder: $(outputFolder)
          type: backend
          rids:
          - framework: netcoreapp3.1
            rid: linux-x64
          - framework: netcoreapp3.1
            rid: linux-musl-x64
          - framework: netcoreapp3.1
            rid: linux-arm64
          - framework: netcoreapp3.1
            rid: linux-musl-arm64
          - framework: netcoreapp3.1
            rid: linux-arm
          - framework: net462
            rid: linux-x64

      - template: publish-template.yml
        parameters:
          folder: '$(outputFolder)/Readarr.Update'
          type: update
          rids:
          - framework: netcoreapp3.1
            rid: linux-x64
          - framework: netcoreapp3.1
            rid: linux-musl-x64
          - framework: netcoreapp3.1
            rid: linux-arm64
          - framework: netcoreapp3.1
            rid: linux-musl-arm64
          - framework: netcoreapp3.1
            rid: linux-arm
          - framework: net462
            rid: linux-x64

      - template: publish-template.yml
        parameters:
          folder: $(testsFolder)
          type: tests
          rids:
          - framework: netcoreapp3.1
            rid: linux-x64
          - framework: netcoreapp3.1
            rid: linux-musl-x64
          - framework: net462
            rid: linux-x64

    - job: Backend_Mac
      pool:
        vmImage: 'macos-10.14'
      variables:
        # Disable stylecop here - linting errors get caught by the analyze task
        EnableAnalyzers: 'false'
      steps:
      - checkout: self
        fetchDepth: 1
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - task: Cache@2
        inputs:
          key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**,!**/_tests/**,!**/_output/**'
          restoreKeys: |
            nuget | "$(Agent.OS)"
            nuget
          path: $(nugetCacheFolder)
        displayName: Cache NuGet packages
      - bash: ./build.sh --backend -r osx-x64 -f netcoreapp3.1
        displayName: Build Readarr Backend
        env:
          NUGET_PACKAGES: $(nugetCacheFolder)
        # Stuff for creating packages later without full checkout

      - template: publish-template.yml
        parameters:
          folder: $(outputFolder)
          type: backend
          rids:
          - framework: netcoreapp3.1
            rid: osx-x64

      - template: publish-template.yml
        parameters:
          folder: '$(outputFolder)/Readarr.Update'
          type: update
          rids:
          - framework: netcoreapp3.1
            rid: osx-x64

      - template: publish-template.yml
        parameters:
          folder: $(testsFolder)
          type: tests
          rids:
          - framework: netcoreapp3.1
            rid: osx-x64

  - stage: Build_Frontend
    displayName: Frontend
    dependsOn: Setup
    jobs:
    - job: Build
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-18.04'
          Mac:
            osName: 'Mac'
            imageName: 'macos-10.14'
          Windows:
            osName: 'Windows'
            imageName: 'windows-2019'
      pool:
        vmImage: $(imageName)
      steps:
      - task: NodeTool@0
        displayName: Set Node.js version
        inputs:
          versionSpec: '10.x'
      - checkout: self
        submodules: true
        fetchDepth: 1
      - task: Cache@2
        inputs:
          key: 'yarn | "$(Agent.OS)" | yarn.lock'
          restoreKeys: |
            yarn | "$(Agent.OS)"
            yarn
          path: $(yarnCacheFolder)
        displayName: Cache Yarn packages
      - bash: ./build.sh --frontend
        displayName: Build Readarr Frontend
        env:
          FORCE_COLOR: 0
          YARN_CACHE_FOLDER: $(yarnCacheFolder)
      - publish: $(outputFolder)
        artifact: '$(osName)Frontend'
        displayName: Publish Frontend
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))
        
  - stage: Installer
    dependsOn:
    - Build_Backend
    - Build_Frontend
    jobs:
    - job: Windows_Installer
      displayName: Create Installer
      pool:
        vmImage: 'windows-2019'
      steps:
      - checkout: self
        fetchDepth: 1
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: netcoreapp3.1-win-x64-backend
          targetPath: _output/netcoreapp3.1/win-x64/publish
        displayName: Fetch Backend
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: netcoreapp3.1-win-x64-update
          targetPath: _output/Readarr.Update/netcoreapp3.1/win-x64/publish
        displayName: Fetch Backend
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: WindowsFrontend
          targetPath: _output
        displayName: Fetch Frontend
      - bash: ./build.sh --packages -r win-x64 -f netcoreapp3.1
        displayName: Create Packages
      - bash: |
          setup/inno/ISCC.exe setup/readarr.iss //DFramework=netcoreapp3.1
          cp setup/output/Readarr.*windows.netcoreapp3.1.exe ${BUILD_ARTIFACTSTAGINGDIRECTORY}/Readarr.${BUILDNAME}.windows-core-x64-installer.exe
        displayName: Create .NET Core Windows installer
      - publish: $(Build.ArtifactStagingDirectory)
        artifact: 'WindowsInstaller'
        displayName: Publish Installer

  - stage: Packages
    dependsOn:
    - Build_Backend
    - Build_Frontend
    jobs:
    - job: Other_Packages
      displayName: Create Standard Packages
      strategy:
        matrix:
          windows_core:
            framework: netcoreapp3.1
            rid: win-x64
            name: windows-core-x64.zip
            folder: windows
            type: zip
            tarCompression: gz
          linux_x64_core:
            framework: netcoreapp3.1
            rid: linux-x64
            name: linux-core-x64.tar.gz
            folder: linux-x64
            type: tar
            tarCompression: gz
          linuxmusl_x64_core:
            framework: netcoreapp3.1
            rid: linux-musl-x64
            name: linux-musl-core-x64.tar.gz
            folder: linux-musl-x64
            type: tar
            tarCompression: gz
          linux_arm64_core:
            framework: netcoreapp3.1
            rid: linux-arm64
            name: linux-core-arm64.tar.gz
            folder: linux-arm64
            type: tar
            tarCompression: gz
          linuxmusl_arm64_core:
            framework: netcoreapp3.1
            rid: linux-musl-arm64
            name: linux-musl-core-arm64.tar.gz
            folder: linux-musl-arm64
            type: tar
            tarCompression: gz
          linux_arm_core:
            framework: netcoreapp3.1
            rid: linux-arm
            name: linux-core-arm.tar.gz
            folder: linux-arm
            type: tar
            tarCompression: gz
          osx_core:
            framework: netcoreapp3.1
            rid: osx-x64
            name: osx-core-x64.tar.gz
            folder: macos
            type: tar
            tarCompression: gz
          osx_app_core:
            framework: netcoreapp3.1
            rid: osx-x64
            name: osx-app-core-x64.zip
            folder: macos-app
            type: zip
            tarCompression: gz
          mono:
            framework: net462
            rid: linux-x64
            name: linux.tar.gz
            folder: linux-x64
            type: tar
            tarCompression: gz

      pool:
        vmImage: 'ubuntu-18.04'

      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: build.sh
          targetPath: .
        displayName: Fetch Build Script
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: MacWrapper
          targetPath: macOS
        displayName: Fetch macOS App Wrapper
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: '$(framework)-$(rid)-backend'
          targetPath: '_output/$(framework)/$(rid)/publish'
        displayName: Fetch Backend
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: '$(framework)-$(rid)-update'
          targetPath: '_output/Readarr.Update/$(framework)/$(rid)/publish'
        displayName: Fetch Backend
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: WindowsFrontend
          targetPath: _output
        displayName: Fetch Frontend
      - bash: |
          chmod a+x build.sh
          ls -lR
          ./build.sh --packages -r $(rid) -f $(framework)
        displayName: Create Packages
      - bash: |
          ls -lR
          find . -name "fpcalc" -exec chmod a+x {} \;
          find . -name "Readarr" -exec chmod a+x {} \;
          find . -name "Readarr.Update" -exec chmod a+x {} \;
        displayName: Set executable bits
      - task: ArchiveFiles@2
        displayName: Compress package
        inputs:
          archiveFile: '$(Build.ArtifactStagingDirectory)/Readarr.$(buildName).$(name)'
          archiveType: $(type)
          tarCompression: $(tarCompression)
          includeRootFolder: false
          rootFolderOrFile: $(artifactsFolder)/$(folder)/$(framework)

      - publish: '$(Build.ArtifactStagingDirectory)/Readarr.$(buildName).$(name)'
        artifact: 'Readarr.$(name)'
        displayName: Publish package

      - bash: |
          echo "Uploading source maps to sentry"
          curl -sL https://sentry.io/get-cli/ | bash
          RELEASENAME="${READARRVERSION}-${BUILD_SOURCEBRANCHNAME}"
          sentry-cli releases new --finalize -p readarr -p readarr-ui -p readarr-update "${RELEASENAME}"
          sentry-cli releases -p readarr-ui files "${RELEASENAME}" upload-sourcemaps _output/UI/ --rewrite
          sentry-cli releases set-commits --auto "${RELEASENAME}"
          if [[ ${BUILD_SOURCEBRANCH} == "refs/heads/develop" ]]; then
          sentry-cli releases deploys "${RELEASENAME}" new -e nightly
          else
          sentry-cli releases deploys "${RELEASENAME}" new -e production
          fi
        displayName: Publish Sentry Source Maps
        condition: |
          and(eq(variables['rid'], 'win-x64'),
          or
          (
            and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop')),
            and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
          ))
        env:
          SENTRY_AUTH_TOKEN: $(sentryAuthTokenServarr)
          SENTRY_ORG: $(sentryOrg)
          SENTRY_URL: $(sentryUrl)
    
  - stage: Unit_Test
    displayName: Unit Tests
    dependsOn: Packages
    condition: succeeded()
    jobs:
    - job: Prepare
      pool:
        vmImage: 'ubuntu-18.04'
      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'not_backend_update'
          targetPath: '.'
      - bash: echo "##vso[task.setvariable variable=backendNotUpdated;isOutput=true]$(cat not_backend_update)"
        name: setVar

    - job: Unit
      displayName: Unit Native
      dependsOn: Prepare
      condition: and(succeeded(), eq(dependencies.Prepare.outputs['setVar.backendNotUpdated'], '0'))

      strategy:
        matrix:
          MacCore:
            osName: 'Mac'
            testName: 'netcoreapp3.1-osx-x64-tests'
            imageName: 'macos-10.14'
          WindowsCore:
            osName: 'Windows'
            testName: 'netcoreapp3.1-win-x64-tests'
            imageName: 'windows-2019'
          LinuxCore:
            osName: 'Linux'
            testName: 'netcoreapp3.1-linux-x64-tests'
            imageName: 'ubuntu-18.04'

      pool:
        vmImage: $(imageName)

      steps:
      - checkout: none
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: '$(testName)'
          targetPath: $(testsFolder)
      - powershell: Set-Service SCardSvr -StartupType Manual
        displayName: Enable Windows Test Service
        condition: and(succeeded(), eq(variables['osName'], 'Windows'))
      - bash: |
          wget https://github.com/acoustid/chromaprint/releases/download/v1.4.3/chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz
          sudo tar xf chromaprint-fpcalc-1.4.3-linux-x86_64.tar.gz --strip-components=1 --directory /usr/bin
          chmod a+x _tests/fpcalc
        displayName: Install fpcalc
        condition: and(succeeded(), eq(variables['osName'], 'Linux'))
      - bash: |
          SYMLINK=6_6_0
          MONOPREFIX=/Library/Frameworks/Mono.framework/Versions/$SYMLINK
          echo "##vso[task.setvariable variable=MONOPREFIX;]$MONOPREFIX"
          echo "##vso[task.setvariable variable=PKG_CONFIG_PATH;]$MONOPREFIX/lib/pkgconfig:$MONOPREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
          echo "##vso[task.setvariable variable=PATH;]$MONOPREFIX/bin:$PATH"
          chmod a+x _tests/fpcalc
        displayName: Set Mono Version and make fpcalc Executable
        condition: and(succeeded(), eq(variables['osName'], 'Mac'))
      - bash: find ${TESTSFOLDER} -name "Readarr.Test.Dummy" -exec chmod a+x {} \;
        displayName: Make Test Dummy Executable
        condition: and(succeeded(), ne(variables['osName'], 'Windows'))
      - bash: |
          chmod a+x ${TESTSFOLDER}/test.sh
          ${TESTSFOLDER}/test.sh ${OSNAME} Unit Test
        displayName: Run Tests
        env:
          TEST_DIR: $(Build.SourcesDirectory)/_tests
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(testName) Unit Tests'
          failTaskOnFailedTests: true

    - job: Unit_Docker
      displayName: Unit Docker
      dependsOn: Prepare
      condition: and(succeeded(), eq(dependencies.Prepare.outputs['setVar.backendNotUpdated'], '0'))
      strategy:
        matrix:
          mono520:
            testName: 'Mono 5.20'
            artifactName: net462-linux-x64-tests
            containerImage: servarr/testimages:mono-5.20
          mono610:
            testName: 'Mono 6.10'
            artifactName: net462-linux-x64-tests
            containerImage: servarr/testimages:mono-6.10
          mono612:
            testName: 'Mono 6.12'
            artifactName: net462-linux-x64-tests
            containerImage: servarr/testimages:mono-6.12
          alpine:
            testName: 'Musl Net Core'
            artifactName: netcoreapp3.1-linux-musl-x64-tests
            containerImage: servarr/testimages:alpine

      pool:
        vmImage: 'ubuntu-18.04'
      
      container: $[ variables['containerImage'] ]

      timeoutInMinutes: 10
        
      steps:
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: $(artifactName)
          targetPath: $(testsFolder)
      - bash: find ${TESTSFOLDER} -name "Readarr.Test.Dummy" -exec chmod a+x {} \;
        displayName: Make Test Dummy Executable
        condition: and(succeeded(), ne(variables['osName'], 'Windows'))
      - bash: |
          chmod a+x ${TESTSFOLDER}/test.sh
          ${TESTSFOLDER}/test.sh Linux Unit Test
        displayName: Run Tests
      - task: PublishTestResults@2
        displayName: Publish Test Results
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(testName) Unit Tests'
          failTaskOnFailedTests: true

  - stage: Integration
    displayName: Integration
    dependsOn: Packages
    jobs:
    - job: Prepare
      pool:
        vmImage: 'ubuntu-18.04'
      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'not_backend_update'
          targetPath: '.'
      - bash: echo "##vso[task.setvariable variable=backendNotUpdated;isOutput=true]$(cat not_backend_update)"
        name: setVar

    - job: Integration_Native
      displayName: Integration Native
      dependsOn: Prepare
      condition: and(succeeded(), eq(dependencies.Prepare.outputs['setVar.backendNotUpdated'], '0'))
      strategy:
        matrix:
          MacCore:
            osName: 'Mac'
            testName: 'netcoreapp3.1-osx-x64-tests'
            imageName: 'macos-10.14'
            artifact: 'Readarr.osx-core-x64.tar.gz'
            pattern: 'Readarr.**.osx-core-x64.tar.gz'
          WindowsCore:
            osName: 'Windows'
            testName: 'netcoreapp3.1-win-x64-tests'
            imageName: 'windows-2019'
            artifact: 'Readarr.windows-core-x64.zip'
            pattern: 'Readarr.**.windows-core-x64.zip'
          LinuxCore:
            osName: 'Linux'
            testName: 'netcoreapp3.1-linux-x64-tests'
            imageName: 'ubuntu-18.04'
            artifact: 'Readarr.linux-core-x64.tar.gz'
            pattern: 'Readarr.**.linux-core-x64.tar.gz'

      pool:
        vmImage: $(imageName)
        
      steps:
      - bash: |
          SYMLINK=6_6_0
          MONOPREFIX=/Library/Frameworks/Mono.framework/Versions/$SYMLINK
          echo "##vso[task.setvariable variable=MONOPREFIX;]$MONOPREFIX"
          echo "##vso[task.setvariable variable=PKG_CONFIG_PATH;]$MONOPREFIX/lib/pkgconfig:$MONOPREFIX/share/pkgconfig:$PKG_CONFIG_PATH"
          echo "##vso[task.setvariable variable=PATH;]$MONOPREFIX/bin:$PATH"
        displayName: Set Mono Version
        condition: and(succeeded(), eq(variables['osName'], 'Mac'))
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: '$(testName)'
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: $(artifact)
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/$(pattern)'
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
        displayName: Extract Package
      - bash: |
          mkdir -p ./bin/
          cp -r -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Readarr/. ./bin/
        displayName: Move Package Contents
      - bash: |
          chmod a+x ${TESTSFOLDER}/test.sh
          ${TESTSFOLDER}/test.sh ${OSNAME} Integration Test
        displayName: Run Integration Tests
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(testName) Integration Tests'
          failTaskOnFailedTests: true
        displayName: Publish Test Results

    - job: Integration_Docker
      displayName: Integration Docker
      dependsOn: Prepare
      condition: and(succeeded(), eq(dependencies.Prepare.outputs['setVar.backendNotUpdated'], '0'))
      strategy:
        matrix:
          mono520:
            testName: 'Mono 5.20'
            artifactName: 'net462-linux-x64-tests'
            containerImage: servarr/testimages:mono-5.20
            artifact: 'Readarr.linux.tar.gz'
            pattern: 'Readarr.**.linux.tar.gz'
          mono610:
            testName: 'Mono 6.10'
            artifactName: 'net462-linux-x64-tests'
            containerImage: servarr/testimages:mono-6.10
            artifact: 'Readarr.linux.tar.gz'
            pattern: 'Readarr.**.linux.tar.gz'
          mono612:
            testName: 'Mono 6.12'
            artifactName: 'net462-linux-x64-tests'
            containerImage: servarr/testimages:mono-6.12
            artifact: 'Readarr.linux.tar.gz'
            pattern: 'Readarr.**.linux.tar.gz'
          alpine:
            testName: 'Musl Net Core'
            artifactName: 'netcoreapp3.1-linux-musl-x64-tests'
            containerImage: servarr/testimages:alpine
            artifact: 'Readarr.linux-musl-core-x64.tar.gz'
            pattern: 'Readarr.**.linux-musl-core-x64.tar.gz'

      pool:
        vmImage: 'ubuntu-18.04'

      container: $[ variables['containerImage'] ]

      timeoutInMinutes: 15
        
      steps:
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: $(artifactName)
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: $(artifact)
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/$(pattern)' 
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
        displayName: Extract Package
      - bash: |
          mkdir -p ./bin/
          cp -r -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Readarr/. ./bin/
        displayName: Move Package Contents
      - bash: |
          chmod a+x ${TESTSFOLDER}/test.sh
          ${TESTSFOLDER}/test.sh Linux Integration Test
        displayName: Run Integration Tests
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(testName) Integration Tests'
          failTaskOnFailedTests: true
        displayName: Publish Test Results

  - stage: Automation
    displayName: Automation
    dependsOn: Packages
    
    jobs:
    - job: Automation
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-18.04'
            testName: 'netcoreapp3.1-linux-x64-tests'
            artifact: 'Readarr.linux-core-x64.tar.gz'
            pattern: 'Readarr.**.linux-core-x64.tar.gz'
            failBuild: true
          Mac:
            osName: 'Mac'
            imageName: 'macos-10.14'
            testName: 'netcoreapp3.1-osx-x64-tests'
            artifact: 'Readarr.osx-core-x64.tar.gz'
            pattern: 'Readarr.**.osx-core-x64.tar.gz'
            failBuild: true
          Windows:
            osName: 'Windows'
            imageName: 'windows-2019'
            testName: 'netcoreapp3.1-win-x64-tests'
            artifact: 'Readarr.windows-core-x64.zip'
            pattern: 'Readarr.**.windows-core-x64.zip'
            failBuild: true

      pool:
        vmImage: $(imageName)
        
      steps:
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - checkout: none
      - task: DownloadPipelineArtifact@2
        displayName: Download Test Artifact
        inputs:
          buildType: 'current'
          artifactName: '$(testName)'
          targetPath: $(testsFolder)
      - task: DownloadPipelineArtifact@2
        displayName: Download Build Artifact
        inputs:
          buildType: 'current'
          artifactName: $(artifact)
          targetPath: $(Build.ArtifactStagingDirectory)
      - task: ExtractFiles@1
        inputs:
          archiveFilePatterns: '$(Build.ArtifactStagingDirectory)/**/$(pattern)' 
          destinationFolder: '$(Build.ArtifactStagingDirectory)/bin'
        displayName: Extract Package
      - bash: |
          mkdir -p ./bin/
          cp -r -v ${BUILD_ARTIFACTSTAGINGDIRECTORY}/bin/Readarr/. ./bin/
        displayName: Move Package Contents
      - bash: |
          if [[ $OSNAME == "Mac" ]]; then
          url=https://github.com/mozilla/geckodriver/releases/download/v0.27.0/geckodriver-v0.27.0-macos.tar.gz
          elif [[ $OSNAME == "Linux" ]]; then
          url=https://github.com/mozilla/geckodriver/releases/download/v0.27.0/geckodriver-v0.27.0-linux64.tar.gz
          else
          echo "Unhandled OS"
          exit 1
          fi
          curl -s -L "$url" | tar -xz
          chmod +x geckodriver
          mv geckodriver _tests
        displayName: Install Gecko Driver
        condition: and(succeeded(), ne(variables['osName'], 'Windows'))
      - bash: |
          chmod a+x ${TESTSFOLDER}/test.sh
          ${TESTSFOLDER}/test.sh ${OSNAME} Automation Test
        displayName: Run Automation Tests
      - task: PublishTestResults@2
        inputs:
          testResultsFormat: 'NUnit'
          testResultsFiles: '**/TestResult.xml'
          testRunTitle: '$(osName) Automation Tests'
          failTaskOnFailedTests: $(failBuild)
        displayName: Publish Test Results

  - stage: Analyze
    dependsOn:
    - Setup
    displayName: Analyze
      
    jobs:
    - job: Prepare
      pool:
        vmImage: 'ubuntu-18.04'
      steps:
      - checkout: none
      - task: DownloadPipelineArtifact@2
        inputs:
          buildType: 'current'
          artifactName: 'not_backend_update'
          targetPath: '.'
      - bash: echo "##vso[task.setvariable variable=backendNotUpdated;isOutput=true]$(cat not_backend_update)"
        name: setVar

    - job: Lint_Frontend
      displayName: Lint Frontend
      strategy:
        matrix:
          Linux:
            osName: 'Linux'
            imageName: 'ubuntu-18.04'
      pool:
        vmImage: $(imageName)
      steps:
      - task: NodeTool@0
        displayName: Set Node.js version
        inputs:
          versionSpec: '10.x'
      - checkout: self
        submodules: true
        fetchDepth: 1
      - task: Cache@2
        inputs:
          key: 'yarn | "$(Agent.OS)" | yarn.lock'
          restoreKeys: |
             yarn | "$(Agent.OS)"
             yarn
          path: $(yarnCacheFolder)
        displayName: Cache Yarn packages
      - bash: ./build.sh --lint
        displayName: Lint Readarr Frontend
        env:
          FORCE_COLOR: 0
          YARN_CACHE_FOLDER: $(yarnCacheFolder)

    - job: Analyze_Frontend
      displayName: Frontend
      condition: eq(variables['System.PullRequest.IsFork'], 'False')
      pool:
        vmImage: windows-2019
      steps:
      - checkout: self # Need history for Sonar analysis
      - task: SonarCloudPrepare@1
        env:
          SONAR_SCANNER_OPTS: ''
        inputs:
          SonarCloud: 'SonarCloud'
          organization: 'readarr'
          scannerMode: 'CLI'
          configMode: 'manual'
          cliProjectKey: 'readarrui'
          cliProjectName: 'ReadarrUI'
          cliProjectVersion: '$(readarrVersion)'
          cliSources: './frontend'
      - task: SonarCloudAnalyze@1

    - job: Analyze_Backend
      displayName: Backend
      pool:
        vmImage: windows-2019
      variables:
        disable.coverage.autogenerate: 'true'
      steps:
      - task: UseDotNet@2
        displayName: 'Install .net core'
        inputs:
          version: $(dotnetVersion)
      - checkout: self # Need history for Sonar analysis
        submodules: true
      - powershell: Set-Service SCardSvr -StartupType Manual
        displayName: Enable Windows Test Service
      - task: SonarCloudPrepare@1
        condition: eq(variables['System.PullRequest.IsFork'], 'False')
        inputs:
          SonarCloud: 'SonarCloud'
          organization: 'readarr'
          scannerMode: 'MSBuild'
          projectKey: 'Readarr_Readarr'
          projectName: 'Readarr'
          projectVersion: '$(readarrVersion)'
          extraProperties: |
            sonar.exclusions=**/obj/**,**/*.dll,**/NzbDrone.Core.Test/Files/**/*,./frontend/**,**/ExternalModules/**,./src/Libraries/**
            sonar.coverage.exclusions=**/Readarr.Api.V1/**/*,**/MonoTorrent/**/*,**/Marr.Data/**/*
            sonar.cs.opencover.reportsPaths=$(Build.SourcesDirectory)/CoverageResults/**/coverage.opencover.xml
            sonar.cs.nunit.reportsPaths=$(Build.SourcesDirectory)/TestResult.xml
      - task: Cache@2
        inputs:
          key: 'nuget | "$(Agent.OS)" | **/packages.lock.json,!**/bin/**,!**/_tests/**,!**/_output/**'
          restoreKeys: |
            nuget | "$(Agent.OS)"
            nuget
          path: $(nugetCacheFolder)
        displayName: Cache NuGet packages
      - bash: |
          ./build.sh --backend -f netcoreapp3.1 -r win-x64
          TEST_DIR=_tests/netcoreapp3.1/win-x64/publish/ ./test.sh Windows Unit Coverage
        displayName: Coverage Unit Tests
        env:
          NUGET_PACKAGES: $(nugetCacheFolder)
      - task: SonarCloudAnalyze@1
        condition: eq(variables['System.PullRequest.IsFork'], 'False')
        displayName: Publish SonarCloud Results
      - task: reportgenerator@4
        displayName: Generate Coverage Report
        inputs:
          reports: '$(Build.SourcesDirectory)/CoverageResults/**/coverage.opencover.xml'
          targetdir: '$(Build.SourcesDirectory)/CoverageResults/combined'
          reporttypes: 'HtmlInline_AzurePipelines;Cobertura;Badges'
      - task: PublishCodeCoverageResults@1
        displayName: Publish Coverage Report
        inputs:
          codeCoverageTool: 'cobertura'
          summaryFileLocation: './CoverageResults/combined/Cobertura.xml'
          reportDirectory: './CoverageResults/combined/'

  - stage: Report_Out
    dependsOn:
    - Analyze
    - Unit_Test
    - Integration
    - Automation
    condition: eq(variables['system.pullrequest.isfork'], false)
    displayName: Build Status Report
    jobs:
    - job:
      displayName: Discord Notification
      pool:
        vmImage: 'ubuntu-18.04'
      steps:
        - checkout: none
        - powershell: |
            iex ((New-Object System.Net.WebClient).DownloadString('https://raw.githubusercontent.com/Servarr/AzureDiscordNotify/master/DiscordNotify.ps1'))
          env:
            SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            DISCORDCHANNELID: $(discordChannelId)
            DISCORDWEBHOOKKEY: $(discordWebhookKey)
